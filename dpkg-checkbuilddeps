#!/usr/bin/perl
#
#  dpkg-checkbuilddeps - Extended sematics of build deps checking
#  Copyright (C) 2006  Wartan Hachaturow <wart@debian.org>
#  Based on original dpkg-checkbuilddeps,
#  Copyright (C) 2001 by Joey Hess <joeyh@debian.org>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#  $Id$

use Getopt::Long;

require "dpkg-cross.pl";

my $control = "debian/control";

# First of all, let's check if we somehow got passed an architecture
$arch = get_architecture();

if ($arch) {
    $do_setup = 1;
}
else {
    $do_setup = 0;
}

# Scan arguments for the ones we're interested in.
# That would introduce -a argument to dpkg-checkbuilddeps
foreach $arg (@ARGV) {
    usage() if $arg =~ /^-h/;
    if ( $arg =~ /^-a/ ) {
        $arch     = $';
        $do_setup = 1;
    }
}

# Chop off -a
@res_argv = grep { !(/^-a/) } @ARGV;

@ADD_ARGS = ();

# We proceed only in the case we're cross-compiling.
# If we're not, we run original dpkg-checkbuilddeps.
if ($do_setup) {
    $mode ||= "default";
    setup_cross_env();
}
else {

    # Call the real dpkg-checkbuilddeps
    my $rv
        = system {"/usr/bin/dpkg-checkbuilddeps.orig"} "dpkg-checkbuilddeps",
        @res_argv, @ADD_ARGS;

    exit $rv >> 8;
}

# What we should do at this point is to parse the control file and check
# if it contains our special fields:
#
# XCS-Cross-Host-Build-Depends:
# 	This field lists the dependencies that have to be present on the build
# 	machine as is, i.e., not installed via dpkg-cross. This includes things
# 	like flex, bison and so on.
# XCS-Cross-Build-Depends:
# 	This field lists the dependencies that have to be present on the build
# 	machine and installed via dpkg-cross, i.e., have -cross prefixes in
# 	their names. Please note that this field should contain original names
# 	of packages, not final "-cross" ones, as this is handled automagically.
# XCS-Cross-Build-Conflicts:
# XCS-Cross-Host-Build-Conflicts:
#	Fields act as above, but work as Conflicts.
#
# All this kind of special stuff happens if and only if we are cross-compiling,
# that is either DPKGCROSSARCH or ARCH is defined in the environment, or we
# are directly passed a "-a" option. If not, then original dpkg-checkbuilddeps
# is run, and regular build-depends check will be performed.
#

my $dpkglibdir = "/usr/lib/dpkg";
push( @INC, $dpkglibdir );
require 'controllib.pl';

$controlfile = $control;

&parsecontrolfile;

my @status = parse_status();
my ( @unmet, @conflicts );
local $/ = '';

my $dep_regex = qr/[ \t]*(([^\n]+|\n[ \t])*)\s/;    # allow multi-line

# For no apparent reason, parsecdata lowercases CS in XCS.
# FIXME?

if ( defined( $fi{"C Xcs-Cross-Host-Build-Depends"} ) ) {

    # As promised, we process this field as is.
    push @unmet,
        build_depends( 'Xcs-Cross-Host-Build-Depends',
        parsedep( $fi{"C Xcs-Cross-Host-Build-Depends"}, 1, 1 ), @status );
}

if ( defined( $fi{"C Xcs-Cross-Build-Depends"} ) ) {

    # And this field should be processed after we go over the list
    # of packages and replace package names with corresponding cross
    # names
    push @unmet,
        build_depends(
        'Xcs-Cross-Host-Build-Depends',
        parsedep(
            crossplist( $fi{"C Xcs-Cross-Build-Depends"}, $arch ),
            1, 1
        ),
        @status
        );
}
if ( defined( $fi{"C Xcs-Cross-Host-Build-Conflicts"} ) ) {
    push @conflicts,
        build_conflicts( 'Xcs-Cross-Host-Build-Conflicts',
        parsedep( $fi{"C Xcs-Cross-Host-Build-Conflicts"}, 1, 1 ), @status );
}

if ( defined( $fi{"C Xcs-Cross-Build-Conflicts"} ) ) {
    push @conflicts,
        build_conflicts(
        'Xcs-Cross-Build-Conflicts',
        parsedep(
            crossplist( $fi{"C Xcs-Cross-Build-Conflicts"}, $arch ),
            1, 1
        ),
        @status
        );
}

# If none of those fields found, then we will exit successfully, meaning
# there are no special build-depends for cross-compilation case.
# Very unlikely.

# I am not sure it is needed.
#
#if (! $binary_only && defined($fi{"C Build-Depends-Indep"})) {
#	push @unmet, build_depends('Build-Depends-Indep',
#				   parsedep($fi{"C Build-Depends-Indep"}, 1, 1),
#				   @status);
#}
#if (! $binary_only && defined($fi{"C Build-Conflicts-Indep"})) {
#	push @conflicts, build_conflicts('Build-Conflicts-Indep',
#					 parsedep($fi{"C Build-Conflicts-Indep"}, 1, 1),
#					 @status);
#}

if (@unmet) {
    printf STDERR _g("%s: Unmet build dependencies: "), $progname;
    print STDERR join( " ", @unmet ), "\n";
}
if (@conflicts) {
    printf STDERR _g("%s: Build conflicts: "), $progname;
    print STDERR join( " ", @conflicts ), "\n";
}
exit 1 if @unmet || @conflicts;

sub usage {

    # print original message
    system "dpkg-checkbuilddeps.orig -h";

    # and our comments...
    print STDERR <<'EOF';

dpkg-cross cross-compiling extension, version $DPKGCROSSVERSION.
Use of -a option makes it parse special control-like file with
build-depends relevant for cross-compiling.
EOF
    exit 0;
}

# This part could be replaced. Silly little status file parser.
# thanks to Matt Zimmerman. Returns two hash references that
# are exactly what the other functions need...
sub parse_status {
    my $status = shift || "/var/lib/dpkg/status";

    my %providers;
    my %version;
    local $/ = '';
    open( STATUS, "<$status" ) || die "$status: $!\n";
    while (<STATUS>) {
        next unless /^Status: .*ok installed$/m;

        my ($package) = /^Package: (.*)$/m;
        push @{ $providers{$package} }, $package;
        ( $version{$package} ) = /^Version: (.*)$/m;

        if (/^Provides: (.*)$/m) {
            foreach ( split( /,\s*/, $1 ) ) {
                push @{ $providers{$_} }, $package;
            }
        }
    }
    close STATUS;

    return \%version, \%providers;
}

# This function checks the build dependencies passed in as the first
# parameter. If they are satisfied, returns false. If they are unsatisfied,
# an list of the unsatisfied depends is returned.
#
# Additional parameters that must be passed:
# * A reference to a hash of all "ok installed" the packages on the system,
#   with the hash key being the package name, and the value being the
#   installed version.
# * A reference to a hash, where the keys are package names, and the
#   value is a true value iff some package installed on the system provides
#   that package (all installed packages provide themselves)
#
# Optionally, the architecture the package is to be built for can be passed
# in as the 4th parameter. If not set, dpkg will be queried for the build
# architecture.
sub build_depends {
    return check_line( 1, @_ );
}

# This function is exactly like unmet_build_depends, except it
# checks for build conflicts, and returns a list of the packages
# that are installed and are conflicted with.
sub build_conflicts {
    return check_line( 0, @_ );
}

# This function does all the work. The first parameter is 1 to check build
# deps, and 0 to check build conflicts.
sub check_line {
    my $build_depends = shift;
    my $fieldname     = shift;
    my $dep_list      = shift;
    my %version       = %{ shift() };
    my %providers     = %{ shift() };
    my $host_arch     = shift || `dpkg-architecture -qDEB_HOST_ARCH`;
    chomp $host_arch;

    my @unmet = ();

    unless ( defined($dep_list) ) {
        &error( sprintf( "error occurred while parsing %s", $fieldname ) );
    }

    foreach my $dep_and (@$dep_list) {
        my $ok        = 0;
        my @possibles = ();
    ALTERNATE: foreach my $alternate (@$dep_and) {
            my ( $package, $relation, $version, $arch_list ) = @{$alternate};

            # This is a possibile way to meet the dependency.
            # Remove the arch stuff from $alternate.
            push @possibles, $package
                . ( $relation && $version ? " ($relation $version)" : '' );

            if ( $relation && $version ) {
                if ( !exists $version{$package} ) {

                    # Not installed at all, so fail.
                    next;
                }
                else {

                    # Compare installed and needed
                    # version number.
                    system( "dpkg", "--compare-versions", $version{$package},
                        $relation, $version );
                    if ( ( $? >> 8 ) != 0 ) {
                        next;    # fail
                    }
                }
            }
            elsif ( !defined $providers{$package} ) {

                # It's not a versioned dependency, and
                # nothing provides it, so fail.
                next;
            }

            # If we get to here, the dependency was met.
            $ok = 1;
        }

        if (@possibles
            && (   ( $build_depends && !$ok )
                || ( !$build_depends && $ok ) )
            )
        {

            # TODO: this could return a more complex
            # data structure instead to save re-parsing.
            push @unmet, join( " | ", @possibles );
        }
    }

    return @unmet;
}

# Rewrite package name
sub make_pkg_name {
    my $pkg  = shift;
    my $arch = shift;

    $pkg .= "-$arch-cross" if $pkg !~ /-\Q$arch\E-cross$/;

    return $pkg;
}

# This function goes over a string containing packages and dependencies,
# and replaces all package-looking words with their dpkg-cross-processed
# counterparts
sub crossplist {
    ( $dep_line, $arch ) = @_;

    my @dep_list = ();

    foreach my $dep_and ( split( /,\s*/m, $dep_line ) ) {
        my @or_list = ();
        foreach my $dep_or ( split( /\s*\|\s*/m, $dep_and ) ) {
            $dep_or
                =~ s/^([a-zA-Z0-9][a-zA-Z0-9+._-]*)/make_pkg_name($1,$arch)/em;
            push @or_list, $dep_or;
        }
        push( @dep_list, join( " | ", @or_list ) );
    }

    return join( ", ", @dep_list );
}

